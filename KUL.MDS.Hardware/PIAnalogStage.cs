using System;
using System.Text;
using System.Linq;
using System.Threading;
using KUL.MDS.ScanModes;
using KUL.MDS.SystemLayer;

using NationalInstruments.DAQmx;

namespace KUL.MDS.Hardware
{
    public class PIAnalogStage : IPiezoStage
    {
        private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        # region Essential Member Objects.

        // The NI Task object that will handle actual stage control.
        private Task m_daqtskMasterClock;
        private Task m_daqtskMoveStage;

        // Writer to write voltages to the stage controller.
        private AnalogMultiChannelWriter m_wrtrVoltageWriter;

        // We need a timing source to run the move at the proper speed.
        private TimingClock m_TimingClock;

        #endregion

        #region Constant Stage Parameters.

        // Constant properties of the stage. These will be used in input validation and safe speed calculation for stage movement.
        private const double m_dNmPVolt = 10000.0;
        private const double m_dMaxPosition = 90000.0;

        // Set global range for the Voltage outputs as an additional safety.
        private const double m_dVoltageMax = 10.0;
        private const double m_dVoltageMin = 0.0;

        #endregion

        #region Members.

        // Create variables to keep track of the currently set voltage to the Piezo stage.
        private double m_dVoltageXCurrent;
        private double m_dVoltageYCurrent;

        // The UI will display data on the acquisition progress during the scan.
        // More specifically, total samples currently sent to stage and total samples taken from APD.
        private int m_iSamplesToStageCurrent;
        private int m_iSamplesFromAPD;
        private int m_iSampleDelta;

        // Status of the stage
        private bool m_bIsInitialized;

        // The variable that holds the voltages to write to the stage.
        private double[,] m_dVoltages;

        #endregion

        #region Properties.

        /// <summary>
        /// This string holds the last error generated by the hardware. "No Error" will be returned if no error occurred.
        /// </summary>
        public string CurrentError
        {
            get
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Returns the current X position of the stage in nm.
        /// </summary>
        public double XPosition
        {
            get
            {
                if (this.m_bIsInitialized)
                {
                    return m_dVoltageXCurrent;
                    //return this.m_iSamplesToStageCurrent;
                    //double[] _dPositions = new double[3];
                    //this.IsError(E7XXController.qPOS(this.m_iControllerID, "123", _dPositions));
                    //return _dPositions[0] * 1000;
                }
                else
                {
                    return -1.0;
                }
            }
        }

        /// <summary>
        /// Returns the current Y position of the stage in nm.
        /// </summary>
        public double YPosition
        {
            get
            {
                if (this.m_bIsInitialized)
                {
                    return m_dVoltageYCurrent;
                    //return this.m_iSamplesToStageCurrent;
                    //double[] _dPositions = new double[3];
                    //this.IsError(E7XXController.qPOS(this.m_iControllerID, "123", _dPositions));
                    //return _dPositions[1] * 1000;
                }
                else
                {
                    return -1.0;
                }
            }
        }

        /// <summary>
        /// Returns the current Y position of the stage in nm.
        /// </summary>
        public double ZPosition
        {
            get
            {
                if (this.m_bIsInitialized)
                {
                    return 0.0;
                    //return this.m_iSamplesToStageCurrent;
                    //double[] _dPositions = new double[3];
                    //this.IsError(E7XXController.qPOS(this.m_iControllerID, "123", _dPositions));
                    //return _dPositions[2] * 1000;
                }
                else
                {
                    return -1.0;
                }
            }
        }

        /// <summary>
        /// Returns the total number of moves already performed during a scan.
        /// </summary>
        public int SamplesWritten
        {
            get
            {
                return this.m_iSamplesToStageCurrent;
            }
        }

        /// <summary>
        /// True if the stage hardware is initialized and ready for use. False otherwise.
        /// </summary>
        public bool IsInitialized
        {
            get
            {
                return this.m_bIsInitialized;
            }
        }

        /// <summary>
        /// True is the stage is moving.
        /// </summary>
        public bool IsMoving
        {
            get
            {
                return true;
                //if (this.Moving() || this.GeneratorRunning())
                //{
                //    return true;
                //}
                //else
                //{
                //    return false;
                //}
            }
        }

        #endregion

        #region Events.

        /// <summary>
        /// Event thrown whenever the stage changed position.
        /// </summary>
        public event EventHandler PositionChanged;

        /// <summary>
        /// Event thrown whenever the hardware generated an error.
        /// </summary>
        public event EventHandler ErrorOccurred;

        /// <summary>
        /// Event thrown whenever the stage is switched on, or off.
        /// </summary>
        public event EventHandler EngagedChanged;

        #endregion

        #region Delegates.

        //private delegate void UIUpdateDelegate();
        //private delegate void ProgressUpdate(int _iProgress);

        #endregion

        #region Singleton Pattern.

        // This class operates according to a singleton pattern. Having multiple PIAnalogStage could be dangerous because the hardware
        // could be left in an unknown state.
        private static volatile PIAnalogStage m_instance;
        private static object m_syncRoot = new object();

        public static PIAnalogStage Instance
        {
            get
            {
                if (m_instance == null)
                {
                    lock (m_syncRoot)
                    {
                        if (m_instance == null)
                        {
                            m_instance = new PIAnalogStage();
                        }
                    }
                }

                return m_instance;
            }
        }
        #endregion

        #region Methods.

        // The constructor obviously needs to be private to prevent normal instantiation.
        private PIAnalogStage()
        {
            // The PIAnalogStage object should be instantiated in an uninitialized state.
            this.m_bIsInitialized = false;
        }

        public void Initialize()
        {
            _logger.Info("Initializing analog Piezo....");

            // Create a new Task object.
            this.m_daqtskMasterClock = new Task();
            Task _daqtskTask = new Task();

            try
            {
                // Setup an Analog Out task to move the Piezo stage along X and Y.
                _daqtskTask.AOChannels.CreateVoltageChannel("/Dev1/ao0", "aoChannelX", m_dVoltageMin, m_dVoltageMax, AOVoltageUnits.Volts);
                _daqtskTask.AOChannels.CreateVoltageChannel("/Dev1/ao1", "aoChannelY", m_dVoltageMin, m_dVoltageMax, AOVoltageUnits.Volts);
                _daqtskTask.AOChannels.CreateVoltageChannel("/Dev1/ao2", "aoChannelZ", m_dVoltageMin, m_dVoltageMax, AOVoltageUnits.Volts);

                _daqtskTask.Control(TaskAction.Verify);

                // Assign the task.
                this.m_daqtskMoveStage = _daqtskTask;

                // Return a status indication for the stage.
                this.m_bIsInitialized = true;
            }

            catch (DaqException exception)
            {
                _daqtskTask.Dispose();
                //MessageBox.Show(exception.Message);
                this.m_bIsInitialized = false;
                _logger.Error("Unable to connect set up AO channels for Move task!");
            }

            // If everything went well, tell everyone :)
            if (EngagedChanged != null)
            {
                EngagedChanged(this, new EventArgs());
            }
        }

        public void Configure(double __dCycleTimeMilisec, int __iSteps)
        {
            try
            {
                double i = __dCycleTimeMilisec * 100000 / 2;

                if (this.m_daqtskMasterClock == null && this.m_daqtskMasterClock == null)
                {
                    this.Initialize();
                }

                this.m_daqtskMasterClock.COChannels.CreatePulseChannelTicks(
                    "/Dev1/Ctr2",
                    "MasterClk",
                    "/Dev1/100MHzTimebase",
                    COPulseIdleState.Low,
                    2,
                    (int)i - 2,
                    (int)i);

                this.m_daqtskMasterClock.Timing.ConfigureImplicit(SampleQuantityMode.FiniteSamples, __iSteps);

                this.m_daqtskMasterClock.Control(TaskAction.Verify);
                this.m_daqtskMasterClock.Control(TaskAction.Commit);

                this.m_daqtskMoveStage.Timing.SampleClockRate = 1000 / __dCycleTimeMilisec;

                this.m_daqtskMoveStage.Timing.ConfigureSampleClock(
                    "/Dev1/Ctr2InternalOutput",
                    1000 / __dCycleTimeMilisec,
                    SampleClockActiveEdge.Rising,
                    SampleQuantityMode.FiniteSamples,
                    __iSteps);

                this.m_daqtskMoveStage.Timing.SampleTimingType = SampleTimingType.SampleClock;

                this.m_daqtskMoveStage.Stream.Buffer.OutputBufferSize = 4096;

                this.m_daqtskMoveStage.Control(TaskAction.Verify);
                this.m_daqtskMoveStage.Control(TaskAction.Commit);
            }

            catch (DaqException ex)
            {
                _logger.Error("Error while configuring daq task!", ex);
            }
        }

        public void Release()
        {
            //this.MoveStage(0, 0);

            try
            {
                if (this.m_daqtskMasterClock != null)
                {
                    this.m_daqtskMasterClock.Stop();
                    this.m_daqtskMasterClock.Control(TaskAction.Unreserve);
                    this.m_daqtskMasterClock.Dispose();
                    this.m_daqtskMasterClock = null;
                }

                // Properly dispose of the AO tasks that control the piezo stage.
                if (this.m_daqtskMoveStage != null)
                {
                    this.m_daqtskMoveStage.Stop();
                    this.m_daqtskMoveStage.Control(TaskAction.Unreserve);
                    this.m_daqtskMoveStage.Dispose();
                    this.m_daqtskMoveStage = null;
                }

                // Return a status indication for the stage.
                this.m_bIsInitialized = false;
            }

            catch (DaqException ex)
            {
                //MessageBox.Show(ex.Message);
                this.m_bIsInitialized = false;
            }
        }

        public void Home()
        {
            this.MoveAbs(0.0, 0.0, 0.0);
        }

        // Calculates voltages for a direct move to a set of XY coordinates.
        private void CalculateMove(double __dInitVoltageX, double __dInitVoltageY, double __dFinVoltageX, double __dFinVoltageY, int __iSteps)
        {
            // Init some variables.
            double _dCurrentVoltageX = __dInitVoltageX;
            double _dCurrentVoltageY = __dInitVoltageY;

            // Calculate the voltage resolution.
            double _dVoltageResX = (__dFinVoltageX - __dInitVoltageX) / __iSteps;
            double _dVoltageResY = (__dFinVoltageY - __dInitVoltageY) / __iSteps;

            // Array to store the voltages for the entire move operation.
            double[,] _dMovement = new double[3, __iSteps];

            // Calculate the actual voltages for the intended movement on X.
            // Movement will be one axis at a time.
            for (int _iI = 0; _iI < __iSteps; _iI++)
            {
                // Increment voltage. 
                // Rounding to 4 digits is done since the voltage resolution of the DAQ board is 305 microvolts.
                _dCurrentVoltageX = Math.Round((__dInitVoltageX + _dVoltageResX * (_iI + 1)), 4);

                // Increment voltage. 
                // Rounding to 4 digits is done since the voltage resolution of the DAQ board is 305 microvolts.
                _dCurrentVoltageY = Math.Round((__dInitVoltageY + _dVoltageResY * (_iI + 1)), 4);

                // Write voltage for X.
                _dMovement[0, _iI] = _dCurrentVoltageX;

                // Write voltage for Y.
                _dMovement[1, _iI] = _dCurrentVoltageY;
            }


            this.m_dVoltages = _dMovement;
        }

        public void MoveAbs(double __dXPosNm, double __dYPosNm, double __dZPosNm)
        {
            try
            {
                // Calculate the voltages that make up the full scan.
                this.CalculateMove(
                    m_dVoltageXCurrent,
                    m_dVoltageYCurrent,
                    this.NmToVoltage(__dXPosNm),
                    this.NmToVoltage(__dYPosNm),
                    1000);

                // Check the generated voltages.
                //double _dMinV = KUL.MDS.Library.Helper.FindMin(m_dVoltages, 2, m_dVoltages.Length / 2);
                //double _dMaxV = KUL.MDS.Library.Helper.FindMax(m_dVoltages, 2, m_dVoltages.Length / 2);

                //if (_dMinV < m_dVoltageMin)
                //{
                //    throw new MinVoltageExceededException("The move you wish to execute will cause a voltage too LOW condition!" +
                //        "\r\n\r\nVoltage Value: " + _dMinV.ToString());
                //}

                //if (_dMaxV > m_dVoltageMax)
                //{
                //    throw new MinVoltageExceededException("The move you wish to execute will cause a voltage too HIGH condition!" +
                //        "\r\n\r\nVoltage Value: " + _dMaxV.ToString());
                //}

                //if (this.m_daqtskMoveStage != null)
                //{
                //if (this.m_daqtskMasterClock != null)
                //{
                //    this.m_daqtskMasterClock.Stop();
                //    this.m_daqtskMasterClock.Control(TaskAction.Unreserve);
                //    this.m_daqtskMasterClock.Dispose();
                //    this.m_daqtskMasterClock = null;
                //}
                //// Setup the timing source.
                //this.m_TimingClock = new TimingClock();
                //this.m_TimingClock.SetupClock(500.0);

                // Prepare the stage control task for writing as many samples as necessary to complete the scan.
                this.Configure(1.0, m_dVoltages.Length / 3);

                double _dProgress = 0.0;

                // Objects to perform reads and writes on our DAQ tasks.
                this.m_wrtrVoltageWriter = new AnalogMultiChannelWriter(this.m_daqtskMoveStage.Stream);

                // Perform the actual AO write.
                this.m_wrtrVoltageWriter.WriteMultiSample(false, m_dVoltages);

                // Start all four tasks in the correct order. Global sync should be last.
                this.m_daqtskMoveStage.Start();
                this.m_daqtskMasterClock.Start();
                //m_daqtskGlobalSync.Start();
                //this.m_TimingClock.Start();

                while (this.m_daqtskMoveStage.IsDone != true)
                {


                    //_logger.Info("ping");

                    // Update the voltages.
                    m_iSamplesToStageCurrent = (int)m_daqtskMoveStage.Stream.TotalSamplesGeneratedPerChannel;

                    if (m_iSamplesToStageCurrent > 0)
                    {
                        m_dVoltageXCurrent = m_dVoltages[0, m_iSamplesToStageCurrent - 1];
                        //_logger.Info("samples: " + m_iSamplesToStageCurrent.ToString());
                        //_logger.Info("Voltage: " + m_dVoltageXCurrent.ToString());
                        m_dVoltageYCurrent = m_dVoltages[1, m_iSamplesToStageCurrent - 1];
                    }

                    _dProgress = ((double)m_iSamplesToStageCurrent / (m_dVoltages.Length / 3)) * 100;
                    _dProgress = Math.Round(_dProgress);
                    _logger.Info("Move Pct. done: " + _dProgress.ToString());
                    if (PositionChanged != null)
                    {
                        PositionChanged(this, new EventArgs());
                    }

                    // Update the UI every 0.1 seconds, more than fast enough.
                    Thread.Sleep(5);
                }

                // Stop the Timing Clock.
                //this.m_TimingClock.Stop();

                // Update the voltages.
                this.m_iSamplesToStageCurrent = (int)m_daqtskMoveStage.Stream.TotalSamplesGeneratedPerChannel;
                //this.m_dVoltageXCurrent = m_dVoltages[0, m_iSamplesToStageCurrent - 1];
                //this.m_dVoltageYCurrent = m_dVoltages[1, m_iSamplesToStageCurrent - 1];

                //// Update Progress.
                _dProgress = ((double)m_iSamplesToStageCurrent / (m_dVoltages.Length / 3)) * 100;

                if (PositionChanged != null)
                {
                    PositionChanged(this, new EventArgs());
                }

                _logger.Info("Move Pct. done: " + _dProgress.ToString());

                //m_daqtskMasterClock.Stop();
                //// Stop the move task for the stage.
                //m_daqtskMoveStage.Stop();

                //m_daqtskMasterClock.Control(TaskAction.Unreserve);
                //m_daqtskMoveStage.Control(TaskAction.Unreserve);

                //m_daqtskMasterClock.Dispose();
                //m_daqtskMoveStage.Dispose();

                //m_daqtskMasterClock = null;
                //m_daqtskMoveStage = null;

                //// Dispose the writer and reader.
                //m_wrtrVoltageWriter = null;
                //}
                //else
                //{
                //    //EnableCtrls();
                //    throw new StageNotEngagedException("The Piezo stage was not engaged properly, please use stage control to engage it!");
                //}
            }

            catch (Exception ex)
            {
                _logger.Error("Crap! : ", ex);
            }

            finally
            {
                m_daqtskMasterClock.Stop();
                // Stop the move task for the stage.
                m_daqtskMoveStage.Stop();

                m_daqtskMasterClock.Control(TaskAction.Unreserve);
                m_daqtskMoveStage.Control(TaskAction.Unreserve);

                m_daqtskMasterClock.Dispose();
                m_daqtskMoveStage.Dispose();

                m_daqtskMasterClock = null;
                m_daqtskMoveStage = null;

                // Dispose the writer and reader.
                m_wrtrVoltageWriter = null;
            }
        }

        public void MoveRel(double __dXPosNm, double __dYPosNm, double __dZPosNm)
        {
        }

        private double NmToVoltage(double __dNmCoordinate)
        {
            double _dVoltage = __dNmCoordinate / m_dNmPVolt;
            return _dVoltage;
        }

        public void Scan(ScanModes.Scanmode __scmScanMode, bool __bResend)
        {
            try
            {
                AnalogMultiChannelWriter writer = new AnalogMultiChannelWriter(this.m_daqtskMoveStage.Stream);

                //myTask.Done += new TaskDoneEventHandler(myTask_Done);

                double[,] test = __scmScanMode.NMScanCoordinates;

               
                int blah = test.GetLength(1);

                for (int i = 0; i < test.GetLength(1); i++)
                {
                    test[0, i] = this.NmToVoltage(__scmScanMode.NMScanCoordinates[0, i]);
                    test[1, i] = this.NmToVoltage(__scmScanMode.NMScanCoordinates[1, i]);
                }

                writer.WriteMultiSample(false, test);
                //this.m_daqtskMoveStage.Start();
                this.m_daqtskMasterClock.Start();
            }
            
            catch (DaqException ex)
            {
                _logger.Error("Error while configuring daq task!", ex);
            }
            
            
        }

        public void Stop()
        {
            this.m_daqtskMasterClock.Stop();
            this.m_daqtskMoveStage.Stop();

            this.m_daqtskMasterClock.Control(TaskAction.Unreserve);
            this.m_daqtskMoveStage.Control(TaskAction.Unreserve);

            this.m_daqtskMasterClock.Dispose();
            this.m_daqtskMoveStage.Dispose();

            this.m_daqtskMasterClock = null;
            this.m_daqtskMoveStage = null;
        }

        #endregion

        

        


    }
}
