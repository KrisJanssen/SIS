using System;
using System.Text;
using System.Linq;
using System.Threading;
using SIS.ScanModes;
using SIS.SystemLayer;

using NationalInstruments.DAQmx;

namespace SIS.Hardware
{
    using System.Diagnostics;
    using System.Net.Mime;
    using System.Xml.Serialization;

    public class NISingleChannelAnalog
    {
        private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        #region Constant Stage Parameters.

        // Constant properties of the stage. These will be used in input validation and safe speed calculation for stage movement.
        private const double m_dNmPVolt = 10000.0;
        private const double m_dMaxPosition = 90000.0;

        // Set global range for the Voltage outputs as an additional safety.
        private const double m_dVoltageMax = 10.0;
        private const double m_dVoltageMin = 0;

        #endregion

        #region Members.

        // The NI Task object that will handle actual stage control.
        // LineTrigger handles a multi bit 'bus' that can be programmed 
        // on a per-pixel basis. This can be used to modulate the main 
        // pulse train for external HW.
        // MasterClock handles the global synchronizing pulse train.
        // MoveStage handles analog output.
        private Task m_daqtskMoveStage;

        private NISampleClock m_sampleClock;
        private double m_samplePeriod;

        // Current array of coordinates for timed stage motion
        private double[,] m_dScanCoordinates;
        private double[,] m_dMoveGeneratorCoordinates;

        // Create variables to keep track of the currently set voltage to the Piezo stage.
        private double m_dCurrentVoltage;

        // The UI will display data on the acquisition progress during the scan.
        // More specifically, total samples currently sent to stage and total samples taken from APD.
        private int m_iSamplesCurrent;

        // Status of the stage
        private bool m_bIsInitialized;

        #endregion

        #region Properties.

        /// <summary>
        /// This string holds the last error generated by the hardware. "No Error" will be returned if no error occurred.
        /// </summary>
        public string CurrentError
        {
            get
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Returns the current X position of the stage in nm.
        /// </summary>
        public double Position
        {
            get
            {
                if (this.m_bIsInitialized)
                {
                    return m_dCurrentVoltage;
                }
                else
                {
                    return -1.0;
                }
            }
        }

        /// <summary>
        /// Returns the total number of moves already performed during a scan.
        /// </summary>
        public int SamplesWritten
        {
            get
            {
                return this.m_iSamplesCurrent;
            }
        }

        /// <summary>
        /// True if the stage hardware is initialized and ready for use. False otherwise.
        /// </summary>
        public bool IsInitialized
        {
            get
            {
                return this.m_bIsInitialized;
            }
        }

        /// <summary>
        /// True is the stage is moving.
        /// </summary>
        public bool IsMoving
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region Events.

        /// <summary>
        /// Event thrown whenever the stage changed position.
        /// </summary>
        public event EventHandler PositionChanged;

        /// <summary>
        /// Event thrown whenever the hardware generated an error.
        /// </summary>
        public event EventHandler ErrorOccurred;

        /// <summary>
        /// Event thrown whenever the stage is switched on, or off.
        /// </summary>
        public event EventHandler EngagedChanged;

        #endregion

        #region Singleton Pattern.

        // This class operates according to a singleton pattern. 
        // Having multiple PIAnalogStage could be dangerous because 
        // the hardware could be left in an unknown state.
        private static volatile NISingleChannelAnalog m_instance;
        private static object m_syncRoot = new object();

        public static NISingleChannelAnalog Instance
        {
            get
            {
                if (m_instance == null)
                {
                    lock (m_syncRoot)
                    {
                        if (m_instance == null)
                        {
                            m_instance = new NISingleChannelAnalog();
                        }
                    }
                }

                return m_instance;
            }
        }
        #endregion

        #region Methods.

        // The constructor obviously needs to be private to prevent normal instantiation.
        private NISingleChannelAnalog()
        {
            // The PIAnalogStage object should be instantiated in an uninitialized state.
            this.m_bIsInitialized = false;
        }

        public void Initialize()
        {
            _logger.Info("Initializing analog Piezo....");

            // Setup an Analog Out task to move the Piezo stage along X and Y.
            Task _daqtskTask = new Task();

            try
            {
                // Add AO channels.
                _daqtskTask.AOChannels.CreateVoltageChannel("/Dev1/ao3", "aoChannelZ", m_dVoltageMin, m_dVoltageMax, AOVoltageUnits.Volts);

                // checked IFilteredTypeDescriptor everything is OK.
                _daqtskTask.Control(TaskAction.Verify);

                // Assign the task.
                this.m_daqtskMoveStage = _daqtskTask;

                // Return a status indication for the stage.
                this.m_bIsInitialized = true;
            }

            catch (DaqException exception)
            {
                if (_daqtskTask != null)
                {
                    _daqtskTask.Dispose();
                }

                this.m_bIsInitialized = false;

                _logger.Error("Unable to connect set up AO channels for Move task!");
            }

            // If everything went well, tell everyone.
            if (EngagedChanged != null)
            {
                EngagedChanged(this, new EventArgs());
            }

            _logger.Info("Init Piezo Done!");
        }

        public void Configure(double __dCycleTimeMilisec, int __iSteps, bool slave)
        {
            this.Configure(__dCycleTimeMilisec, __iSteps, slave, true);
        }

        public void Configure(double __dCycleTimeMilisec, int __iSteps, bool slave, bool continuous)
        {
            string trigger;
            _logger.Info("Configuring stage timing....");

            if (this.m_sampleClock != null)
            {
                this.m_sampleClock = new NISampleClock("Dev1", "Ctr3");
                this.m_samplePeriod = __dCycleTimeMilisec / 1000;
            }
            if(slave)
            {
                trigger = "/Dev1/Ctr2InternalOutput";
            }
            else
            {
                trigger = "/Dev1/Ctr3InternalOutput";
            }

            try
            {

                if (this.m_daqtskMoveStage == null)
                {
                    this.Initialize();
                }

                if (continuous)
                {
                    this.m_daqtskMoveStage.Timing.SampleTimingType = SampleTimingType.SampleClock;

                    this.m_daqtskMoveStage.Timing.ConfigureSampleClock(
                        trigger,
                        1000 / __dCycleTimeMilisec,
                        SampleClockActiveEdge.Rising,
                        SampleQuantityMode.ContinuousSamples,
                        __iSteps);
                }

                if (!continuous)
                {
                    this.m_daqtskMoveStage.Timing.SampleTimingType = SampleTimingType.SampleClock;

                    this.m_daqtskMoveStage.Timing.ConfigureSampleClock(
                        trigger,
                        1000 / __dCycleTimeMilisec,
                        SampleClockActiveEdge.Rising,
                        SampleQuantityMode.FiniteSamples,
                        __iSteps);
                }
            }

            catch (DaqException ex)
            {
                _logger.Error("Error while setting timing!", ex);
            }
        }

        public void Release()
        {
            this.Home();

            try
            {
                // Properly dispose of the AO tasks that control the piezo stage.
                if (this.m_daqtskMoveStage != null)
                {
                    this.m_daqtskMoveStage.Stop();
                    this.m_daqtskMoveStage.Control(TaskAction.Unreserve);
                    this.m_daqtskMoveStage.Dispose();
                    this.m_daqtskMoveStage = null;
                }

                // Return a status indication for the stage.
                this.m_bIsInitialized = false;
            }

            catch (DaqException ex)
            {
                //MessageBox.Show(ex.Message);
                this.m_bIsInitialized = false;
            }

            this.m_sampleClock.Stop();

            // If everything went well, tell everyone :)
            if (EngagedChanged != null)
            {
                EngagedChanged(this, new EventArgs());
            }
        }

        public void Home()
        {
            this.MoveAbs(0.0, 0.0, 0.0);
        }

        // Calculates voltages for a direct move to a set of XY coordinates.
        private double[,] CalculateMove(double __dInitVoltageX, double __dFinVoltageX, int __iSteps)
        {
            // Init some variables.
            double _dCurrentVoltageX = __dInitVoltageX;

            // Calculate the voltage resolution.
            double _dVoltageResX = (__dFinVoltageX - __dInitVoltageX) / __iSteps;

            // Array to store the voltages for the entire move operation.
            double[,] _dMovement = new double[1,__iSteps];

            // Calculate the actual voltages for the intended movement on X.
            // Movement will be one axis at a time.
            for (int _iI = 0; _iI < __iSteps; _iI++)
            {
                // Increment voltage. 
                // Rounding to 4 digits is done since the voltage resolution of the DAQ board is 305 microvolts.
                _dCurrentVoltageX = Math.Round((__dInitVoltageX + _dVoltageResX * (_iI + 1)), 4);

                // Write voltage for X.
                _dMovement[0, _iI] = _dCurrentVoltageX;
            }


            return _dMovement;
        }

        public void MoveAbs(double __dXPosNm, double __dYPosNm, double __dZPosNm)
        {
            // Calculate the voltages that make up the full scan.
            this.m_dMoveGeneratorCoordinates = this.CalculateMove(
                m_dCurrentVoltage,
                this.NmToVoltage(__dXPosNm),
                1000);

            int[] levels = Enumerable.Repeat(0, this.m_dMoveGeneratorCoordinates.GetLength(1)).ToArray();

            this.TimedMove(1.0, this.m_dMoveGeneratorCoordinates, false, false);

            while (this.m_daqtskMoveStage.IsDone != true)
            {
                Thread.Sleep(100);
            }

            this.Stop();
        }

        public void MoveRel(double __dXPosNm)
        {
        }

        private double VoltageToNm(double __dVoltage)
        {
            double _dNm = __dVoltage * m_dNmPVolt;
            return _dNm;
        }

        private double NmToVoltage(double __dNmCoordinate)
        {
            double _dVoltage = __dNmCoordinate / m_dNmPVolt;
            return _dVoltage;
        }

        public void Scan(int length, double __dPixelTime, bool __bResend)
        {
            if (__bResend | this.m_dScanCoordinates == null)
            {
                // Allocate space for the full image
                double[,] coordinates =
                    new double[1, length * 5];

                int i = 0;

                for (int j = 0; j < length; j++)
                {
                    coordinates[0, j + (i * length)] = this.m_dCurrentVoltage;
                }

                i = 1;

                for (int j = 0; j < length; j++)
                {
                    coordinates[0, j + (i * length)] = this.m_dCurrentVoltage + 1;
                }

                i = 2;

                for (int j = 0; j < length; j++)
                {
                    coordinates[0, j + (i * length)] = this.m_dCurrentVoltage;
                }

                i = 3;

                for (int j = 0; j < length; j++)
                {
                    coordinates[0, j + (i * length)] = this.m_dCurrentVoltage - 1;
                }

                i = 4;

                for (int j = 0; j < length; j++)
                {
                    coordinates[0, j + (i * length)] = this.m_dCurrentVoltage - 1;
                }

                this.m_dScanCoordinates = coordinates;
            }
            this.m_dMoveGeneratorCoordinates = this.m_dScanCoordinates;
            // Perform the actual scan as a timed move.
            this.TimedMove(__dPixelTime, this.m_dScanCoordinates, true, true);
        }

        public void Stop()
        {
            this.m_iSamplesCurrent = (int)m_daqtskMoveStage.Stream.TotalSamplesGeneratedPerChannel; //% m_dMoveGeneratorCoordinates.GetLength(1);
            
            this.m_daqtskMoveStage.Stop();
            this.m_sampleClock.Stop();

            if (this.m_iSamplesCurrent > 0)
            {
                int temp = m_iSamplesCurrent % this.m_dMoveGeneratorCoordinates.GetLength(1);
                if (temp == 0)
                {
                    temp = m_iSamplesCurrent;
                }
                m_dCurrentVoltage = m_dMoveGeneratorCoordinates[0, temp - 1];
            }

            _logger.Info("written : " + m_daqtskMoveStage.Stream.TotalSamplesGeneratedPerChannel.ToString());

            if (PositionChanged != null)
            {
                PositionChanged(this, new EventArgs());
            }
        }

        private void TimedMove(double __dCycleTime, double[,] __dCoordinates, bool slave, bool continuous)
        {
            Stopwatch watch = new Stopwatch();

            watch.Start();
            _logger.Debug("Start:" + watch.ElapsedMilliseconds.ToString());
            int _iSamplesPerChannel = __dCoordinates.Length / 3;

            // Prepare the stage control task for writing as many samples as necessary to complete Move.
            this.Configure(__dCycleTime, _iSamplesPerChannel, slave, continuous);

            // Keep track of the progress on the output task.
            double _dProgress = 0.0;

            AnalogMultiChannelWriter writerA = new AnalogMultiChannelWriter(this.m_daqtskMoveStage.Stream);

            try
            {
                // Perform the actual AO write.
                writerA.WriteMultiSample(false, __dCoordinates);
                _logger.Debug("End write:" + watch.ElapsedMilliseconds.ToString());

                // Start all four tasks in the correct order. Global sync should be last.
                this.m_sampleClock.Start(this.m_samplePeriod);

                // Update the voltages one last time.
                if (m_iSamplesCurrent > 0)
                {
                    this.m_iSamplesCurrent = (int)m_daqtskMoveStage.Stream.TotalSamplesGeneratedPerChannel;
                    m_dCurrentVoltage = m_dMoveGeneratorCoordinates[0, m_iSamplesCurrent - 1];
                }

                // Update Progress.
                _dProgress = ((double)m_iSamplesCurrent / (_iSamplesPerChannel)) * 100;

                if (PositionChanged != null)
                {
                    PositionChanged(this, new EventArgs());
                }

                _logger.Info("Move Pct. done: " + _dProgress.ToString());
            }

            catch (Exception ex)
            {
                _logger.Error("Something went wrong! : \r\n", ex);
                m_daqtskMoveStage.Stop();
            }
        }

        #endregion

    }
}
